<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>K8s - 现实和梦想</title><meta name=keywords content="博客,程序员,架构,学习,思考,读书,笔记,技术,分享,开发"><meta name=author content="菩提本树"><meta property="og:title" content="K8s"><meta property="og:site_name" content="现实和梦想"><meta property="og:image" content="/img/author.jpg"><meta name=title content="K8s - 现实和梦想"><meta name=description content="欢迎来到jansonlv博客空间，个人主要专注于程序开发，架构"><link rel="shortcut icon" href=/img/favicon.ico><link rel=apple-touch-icon href=/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=/img/apple-touch-icon.png><link href=//cdn.bootcdn.net/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.css rel=stylesheet><link href=/css/main.css rel=stylesheet type=text/css><link href=/css/syntax.css rel=stylesheet type=text/css><script type=text/javascript>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?Your BaiduSiteId",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=Your%20GoogleSiteId"></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','Your GoogleSiteId ')</script></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><div class=multi-lang-switch><i class="fa fa-fw fa-language" style=margin-right:5px></i>
<a class=lang-link id=zh-cn href=#>中文</a></div><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>现实和梦想</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>jansonlv</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class=menu-item><a href=/404.html rel=section><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=/post/k8s/ itemprop=url>K8s</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i>
<span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2021-09-17">2021-09-17</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i>
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=/categories/%E5%AD%A6%E4%B9%A0 itemprop=url rel=index style=text-decoration:underline><span itemprop=name>学习</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i>
<span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>7572 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i>
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>16分钟</span></span>
<span id=/post/k8s/ class=leancloud_visitors data-flag-title=K8s>|
<i class="fa fa-binoculars fa-fw"></i>
<span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><h1 id=容器篇>容器篇</h1><p>**## **进程</p><p><strong>进程是分配资源的最小单元</strong></p><p><strong>容器技术的核心功能，就是通过约束资源和修改进程的动态表现，从而为其创造出一个边界。</strong></p><p><strong>Cgroups</strong>技术就是用来制造约束的主要手段**
****Namespace**技术则是用来修改进程视图的主要方法**
****rootfs**挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统</p><h1 id=k8s-篇>K8S 篇</h1><p><strong>k8s：按照用户的意愿和整个系统的规则，完全自动化的处理好容器之间的各种关系。也就是****编排</strong>，本质就是为用户提供一个具有普遍意义的容器编排工具</p><h2 id=安装>安装：</h2><p><strong>使用</strong><a href=https://kind.sigs.k8s.io/docs/user/quick-start#creating-a-cluster>kind</a>做k8s安装，也可以使用kubeadm**
**docker内置安装<a href=https://codechina.csdn.net/mirrors/AliyunContainerService/k8s-for-docker-desktop/-/tree/v1.21.3>https://codechina.csdn.net/mirrors/AliyunContainerService/k8s-for-docker-desktop/-/tree/v1.21.3</a></p><p><strong>个人推荐docker内置安装，避免翻墙</strong></p><h2 id=简单使用后期补充都是新手教程>简单使用（后期补充，都是新手教程）</h2><h3 id=元数据>元数据</h3><h3 id=发布一个应用>发布一个应用</h3><h3 id=修改一个应用>修改一个应用</h3><h3 id=挂载目录>挂载目录</h3><h3 id=进入容器>进入容器</h3><h3 id=删除一个应用>删除一个应用</h3><h3 id=执行一个job>执行一个job</h3><ol><li><strong>kubectl apply -f xxxxx （任务已存在不可重复执行，需要先delete）</strong></li><li><strong>强制重启kubectl replace –force -f xxxxx</strong></li></ol><h2 id=pod>Pod</h2><p><strong>Pod，其实是一组共享了某些资源的容器， pod里的所有容器，共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume。</strong></p><h3 id=为什么需要pod>为什么需要pod</h3><h4 id=pod和容器之间的关系>pod和容器之间的关系</h4><h4 id=使用pod的优点>使用pod的优点</h4><h3 id=pod的基础使用>pod的基础使用</h3><h4 id=如何理解一切属性namespace的操作都是pod级别的>如何理解一切属性、namespace的操作都是pod级别的</h4><h4 id=相关操作>相关操作</h4><ol><li><strong>共享进程（pid namespace）</strong></li><li><strong>Lifecycle 容器的hook</strong></li></ol><h4 id=pod对象在k8s中的声明周期>pod对象在k8s中的声明周期</h4><p><strong>pod的状态</strong></p><h3 id=pod-进阶操作>pod 进阶操作</h3><h4 id=volume-投射数据卷>Volume 投射数据卷</h4><p><strong>用来为容器促提供预制好的数据的，比如配置等</strong>
<strong>常见的Projected Volume一共有四种</strong></p><ol><li><strong>Secret</strong></li><li><strong>ConfigMap</strong></li><li><strong>Downward API</strong></li><li><strong>ServiceAccountToken</strong></li></ol><h4 id=健康检查和恢复机制>健康检查和恢复机制</h4><h4 id=podpreset-pod预设值功能很实用>PodPreset Pod预设值功能（很实用）</h4><h3 id=控制器模型>控制器模型</h3><h4 id=控制器定义>控制器定义</h4><h4 id=被控制对象>被控制对象</h4><h4 id=和实践驱动的区别和练习>和实践驱动的区别和练习</h4><h3 id=副本和扩展>副本和扩展</h3><p><strong>Deployment 控制器实际操纵的，正是这样的 ReplicaSet （副本集）对象，而不是 Pod 对象。</strong></p><p><strong>对于一个 Deployment 所管理的 Pod，它的 ownerReference 是ReplicaSet</strong></p><p><strong>一个 ReplicaSet 对象，其实就是由副本数目的定义和一个 Pod 模板组成的。</strong></p><p><img src=./01/png alt=副本集></p><p><strong>可以通过kubectl get rs 查看</strong></p><h4 id=滚动发布>滚动发布</h4><h4 id=扩展>扩展</h4><h4 id=回滚>回滚</h4><h4 id=回滚指定版本>回滚指定版本</h4><p><a href=https://github.com/ContainerSolutions/k8s-deployment-strategies/tree/master/canary>金丝雀发布</a></p><h3 id=深入理解statefulset一拓扑状态>深入理解StatefulSet（一）：拓扑状态</h3><p><strong>两种状态</strong></p><ol><li><strong>拓扑状态：多个应用按照顺序启动，有依赖关系</strong></li><li><strong>存储状态：应用的多个实例分别绑定了不同的存储数据</strong></li></ol><p><strong>StatefulSet 的核心功能，就是通过某种方式记录这些状态，然后在 Pod 被重新创建时，能够为新 Pod 恢复这些状态。</strong></p><p><strong>service如何被访问：</strong></p><ol><li><strong>service vip模式：虚拟ip，通过直接访问虚拟ip时，直接转发该service代理的某个pod上</strong></li><li><strong>以service的DNS方式：访问service会访问到其代理的DNS记录， 就可以访问到service所代理的pod</strong></li></ol><p><strong>StatefulSet 这个控制器的主要作用之一，就是使用 Pod 模板创建 Pod 的时候，对它们进行编号，并且按照编号顺序逐一完成创建工作。而当 StatefulSet 的“控制循环”发现 Pod 的“实际状态”与“期望状态”不一致，需要新建或者删除 Pod 进行“调谐”的时候，它会严格按照这些 Pod 编号的顺序，逐一完成这些操作。</strong></p><p><strong>所以，StatefulSet 其实可以认为是对 Deployment 的改良。</strong></p><p><strong>与此同时，通过 Headless Service 的方式，StatefulSet 为每个 Pod 创建了一个固定并且稳定的 DNS 记录，来作为它的访问入口。</strong></p><p><strong>实际上，在部署“有状态应用”的时候，应用的每个实例拥有唯一并且稳定的“网络标识”，是一个非常重要的假设。</strong></p><h3 id=深入理解statefulset二存储状态>深入理解StatefulSet（二）：存储状态</h3><p><strong>Volume之PVC（Persistent Volume Claim）</strong></p><p><strong>简单来说就是使用PV申明一个类似分布式存储的PersistentVolume pod服务，提供PVC给pod调用</strong></p><p><strong>PVC 其实就是一种特殊的 Volume。只不过一个 PVC 具体是什么类型的 Volume，要在跟某个 PV 绑定之后才知道。</strong></p><p><strong>首先，StatefulSet 的控制器直接管理的是 Pod。这是因为，StatefulSet 里的不同 Pod 实例，不再像 ReplicaSet 中那样都是完全一样的，而是有了细微区别的。比如，每个 Pod 的 hostname、名字等都是不同的、携带了编号的。而 StatefulSet 区分这些实例的方式，就是通过在 Pod 的名字里加上事先约定好的编号。</strong></p><p><strong>其次，Kubernetes 通过 Headless Service，为这些有编号的 Pod，在 DNS 服务器中生成带有同样编号的 DNS 记录。只要 StatefulSet 能够保证这些 Pod 名字里的编号不变，那么 Service 里类似于 web-0.nginx.default.svc.cluster.local 这样的 DNS 记录也就不会变，而这条记录解析出来的 Pod 的 IP 地址，则会随着后端 Pod 的删除和再创建而自动更新。这当然是 Service 机制本身的能力，不需要 StatefulSet 操心。</strong></p><p><strong>最后，StatefulSet 还为每一个 Pod 分配并创建一个同样编号的 PVC。这样，Kubernetes 就可以通过 Persistent Volume 机制为这个 PVC 绑定上对应的 PV，从而保证了每一个 Pod 都拥有一个独立的 Volume。</strong></p><p><strong>在这种情况下，即使 Pod 被删除，它所对应的 PVC 和 PV 依然会保留下来。所以当这个 Pod 被重新创建出来之后，Kubernetes 会为它找到同样编号的 PVC，挂载这个 PVC 对应的 Volume，从而获取到以前保存在 Volume 里的数据。</strong></p><p><strong>从这些讲述中，我们不难看出 StatefulSet 的设计思想：StatefulSet 其实就是一种特殊的 Deployment，而其独特之处在于，它的每个 Pod 都被编号了。而且，这个编号会体现在 Pod 的名字和 hostname 等标识信息上，这不仅代表了 Pod 的创建顺序，也是 Pod 的重要网络标识（即：在整个集群里唯一的、可被的访问身份）。</strong></p><p><strong>有了这个编号后，StatefulSet 就使用 Kubernetes 里的两个标准功能：Headless Service 和 PV/PVC，实现了对 Pod 的拓扑状态和存储状态的维护。</strong></p><p><strong>实际上，在下一篇文章的“有状态应用”实践环节，以及后续的讲解中，你就会逐渐意识到，StatefulSet 可以说是 Kubernetes 中作业编排的“集大成者”。</strong></p><p><strong>因为，几乎每一种 Kubernetes 的编排功能，都可以在编写 StatefulSet 的 YAML 文件时被用到。</strong></p><h3 id=深入理解statefulset三有状态应用实践>深入理解StatefulSet（三）：有状态应用实践</h3><p><strong>搭建一主多从的mysql服务</strong></p><h3 id=容器化守护进程的意义daemonset>容器化守护进程的意义：DaemonSet</h3><p><strong>DaemonSet特征：</strong></p><ol><li><strong>每个节点****必有且只有一个</strong>这样的pod实例</li><li><strong>当有新的节点加入集群，该pod就会自动的再新节点上被创建</strong></li></ol><p><strong>使用场景：</strong></p><ol><li><strong>日志上报</strong></li><li><strong>节点监控</strong></li><li><strong>k8s网络基础服务</strong></li></ol><p><strong>每个节点上有且只有一个 Pod的保证基础：</strong>
<strong>nodeAffinity</strong>
<strong>Toleration</strong></p><h3 id=撬动离线业务job与cronjob>撬动离线业务：Job与CronJob</h3><p><strong>重启策略：restartPolicy</strong>
<strong>重启次数：backoffLimit</strong>
<strong>运行最大时间：activeDeadlineSeconds</strong></p><h4 id=job-controller并行作业>job controller并行作业</h4><p><strong>parallelism：定义一个job在任意时间最多可以启动多少个pod</strong>
<strong>completions：定义的是job至少要完成的pod数量，即job最小完成数</strong></p><h4 id=三种常用的job用法>三种常用的job用法</h4><ol><li><strong>最简单粗暴的用法：外部管理器 +Job 模板。（参考KubeFlow）</strong></li><li><strong>拥有固定任务数目的并行 Job</strong></li><li><strong>指定并行度（parallelism），但不设置固定的 completions 的值。</strong></li></ol><h4 id=cronjob-job重复策略>cronjob job重复策略</h4><ol><li><strong>concurrencyPolicy=Allow，这也是默认情况，这意味着这些 Job 可以同时存在</strong></li><li><strong>concurrencyPolicy=Forbid，这意味着不会创建新的 Pod，该创建周期被跳过</strong></li><li><strong>concurrencyPolicy=Replace，这意味着新产生的 Job 会替换旧的、没有执行完的 Job</strong></li></ol><p><strong>而如果某一次 Job 创建失败，这次创建就会被标记为“miss”。当在指定的时间窗口内，miss 的数目达到 100 时，那么 CronJob 会停止再创建这个 Job</strong></p><h3 id=声明式api与kubernetes编程范式>声明式API与Kubernetes编程范式</h3><p><strong>kubectl create，再 replace 的操作，我们称为命令式配置文件操作，替换原有的api对象</strong></p><p><strong>kubectl apply 声明式 API：是对原有的api对象操作</strong></p><ol><li><strong>指的就是我只需要提交一个定义好的 API 对象来“声明”，我所期望的状态是什么样子。</strong></li><li><strong>“声明式 API”允许有多个 API 写端，以 PATCH 的方式对 API 对象进行修改，而无需关心本地原始 YAML 文件的内容。</strong></li><li><strong>最后，也是最重要的，有了上述两个能力，Kubernetes 项目才可以基于对 API 对象的增、删、改、查，在完全无需外界干预的情况下，完成对“实际状态”和“期望状态”的调谐（Reconcile）过程。</strong></li></ol><p><strong>声明式 API，才是 Kubernetes 项目编排能力“赖以生存”的核心所在</strong></p><p><strong>声明式api的好处，是不会重复生成对象，因为很多情况下都需要初始化处理</strong></p><h4 id=深入解析声明式api一api对象的奥秘>深入解析声明式API（一）：API对象的奥秘</h4><p><strong>有点难</strong></p><h4 id=深入解析声明式api二编写自定义控制器>深入解析声明式API（二）：编写自定义控制器</h4><p><strong>后期使用</strong></p><h4 id=rbac-角色权限控制>RBAC 角色权限控制</h4><p><strong>偏于运维，过</strong></p><h4 id=聪明的微创新operator工作原理解读>聪明的微创新：Operator工作原理解读</h4><p><strong>后面在学吧</strong></p><p><a href=https://kubernetes.io/zh/docs/concepts/extend-kubernetes/operator/>官方介绍</a>
<a href=https://sdk.operatorframework.io/docs/overview/>operatorframework官方文档</a>
<a href=https://www.servicemesher.com/blog/kubernetes-crd-quick-start/>如何从零开始编写一个Kubernetes CRD</a>
<a href=https://www.qikqiak.com/post/k8s-operator-101/>Kubernetes Operator 快速入门教程</a>
<a href=https://zhuanlan.zhihu.com/p/246550722>知乎：十分钟弄懂 k8s Operator 应用的制作流程</a>
<a href=https://www.yht7.com/kubernetes/6916.html>云海天：Operator</a>
<a href=https://yuerblog.cc/2019/08/13/k8s-%e5%85%89%e9%80%9f%e7%90%86%e8%a7%a3operator/>K8S – 光速理解operator</a>
<a href=https://www.jianshu.com/p/ad859a279d9a>如何在kubernetes中开发自己的Operator</a>
<a href=https://www.bookstack.cn/read/KubeOperator-2.0/646ef3fa13db2f0a.md>书栈网：KubeOperator v2.0 使用教程</a>
<a href=http://weekly.dockerone.com/article/9088>Kubernetes Operator最佳实践</a></p><h3 id=存储卷pvpvcstorageclassflexvolume与csi>存储卷：PV、PVC、StorageClass，FlexVolume与CSI</h3><p><strong>PV：是持久化存储的数据卷。是定义的一个持久化存储在宿主机上的目录，描述。</strong>
<strong>PVC：Pod所希望使用的持久化存储的属性。比如Volume存储的大小，权限等。</strong></p><p><strong>用go举个例子：PV就是一个对象具体实现了一个方法；pvc就是通过接口签名调用了pv这个方法。</strong></p><p><strong>这样做的好处是，作为应用开发者，我们只需要跟 PVC 这个“接口”打交道，而不必关心具体的实现是 NFS 还是 Ceph。毕竟这些存储相关的知识太专业了，应该交给专业的人去做。</strong></p><p><strong>CSI插件编写等</strong></p><h3 id=容器网络>容器网络</h3><p><strong>Linux 容器能看见的“网络栈”，实际上是被隔离在它自己的 Network Namespace 当中的。</strong></p><p><strong>网络栈：网卡（Network Interface）、回环设备（Loopback Device）、路由表（Routing Table）和 iptables 规则。</strong></p><p><strong>在大多数情况下，我们都希望容器进程能使用自己 Network Namespace 里的网络栈，即：拥有属于自己的 IP 地址和端口。</strong></p><p><strong>这个被隔离的容器进程，该如何跟其他 Network Namespace 里的容器进程进行交互呢？</strong></p><p><strong>在 Linux 中，能够起到虚拟交换机作用的网络设备，是网桥（Bridge）。它是一个工作在数据链路层（Data Link）的设备，主要功能是根据 MAC 地址学习来将数据包转发到网桥的不同端口（Port）上。</strong></p><p><strong>当然，至于为什么这些主机之间需要 MAC 地址才能进行通信，这就是网络分层模型的基础知识了。不熟悉这块内容的读者，可以通过</strong><a href=https://www.lifewire.com/layers-of-the-osi-model-illustrated-818017>这篇文章</a>来学习一下。</p><p><strong>为了实现上述目的，Docker 项目会默认在宿主机上创建一个名叫 docker0 的网桥，凡是连接在 docker0 网桥上的容器，就可以通过它来进行通信。</strong></p><p><strong>可是，我们又该如何把这些容器“连接”到 docker0 网桥上呢？</strong></p><p><strong>这时候，我们就需要使用一种名叫Veth Pair的虚拟设备了。</strong></p><p><strong>Veth Pair 设备的特点是：它被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式成对出现的。并且，从其中一个“网卡”发出的数据包，可以直接出现在与它对应的另一张“网卡”上，哪怕这两个“网卡”在不同的 Network Namespace 里。</strong></p><p><strong>这就使得 Veth Pair 常常被用作连接不同 Network Namespace 的“网线”。</strong></p><h4 id=深入解析容器跨主机网络>深入解析容器跨主机网络</h4><p><strong>理解容器“跨主通信”的原理，就一定要先从 Flannel 这个项目说起。</strong></p><p><strong>Flannel 项目是 CoreOS 公司主推的容器网络方案。事实上，Flannel 项目本身只是一个框架，真正为我们提供容器网络功能的，是 Flannel 的后端实现。目前，Flannel 支持三种后端实现，分别是：</strong></p><ol><li><strong>VXLAN</strong></li><li><strong>host-gw</strong></li><li><strong>UDP</strong></li></ol><p><strong>这三种不同的后端实现，正代表了三种容器跨主网络的主流实现方法。</strong></p><p><strong>CNI 网络插件</strong></p><p><strong>Fannel host-gw 模式和 Calico 这两种纯三层网络方案</strong></p><p><strong>NetworkPolicy：设置流量白名单</strong></p><h5 id=找到容器不容易servicedns与服务发现>找到容器不容易：Service、DNS与服务发现</h5><p><strong>Service</strong> 是由 kube-proxy 组件，加上 iptables 来共同实现的。</p><p><strong>kubeproxy通过组件感知到service对象添加，会在iptables上添加规则（该规则就是为service设置一个固定的入口地址）：目的地址是xxxx，端口是xx的ip包都跳转到另一条iptables链路中处理，这条链路是一组规则的集合，其实也就是代理的pod的最终地址。</strong></p><p><strong>问题：一直以来，基于 iptables 的 Service 实现，都是制约 Kubernetes 项目承载更多量级的 Pod 的主要障碍。</strong></p><p><strong>而 IPVS 模式的 Service，就是解决这个问题的一个行之有效的方法。</strong></p><p><strong>IPVS 模式的工作原理，其实跟 iptables 模式类似。当我们创建了前面的 Service 之后，kube-proxy 首先会在宿主机上创建一个虚拟网卡（叫作：kube-ipvs0），并为它分配 Service VIP 作为 IP 地址。</strong></p><p><strong>接下来，kube-proxy 就会通过 Linux 的 IPVS 模块，为这个 IP 地址设置三个 IPVS 虚拟主机，并设置这三个虚拟主机之间使用轮询模式 (rr) 来作为负载均衡策略。我们可以通过 ipvsadm 查看到这个设置。</strong></p><p><strong>相比于 iptables，IPVS 在内核中的实现其实也是基于 Netfilter 的 NAT 模式，所以在转发这一层上，理论上 IPVS 并没有显著的性能提升。但是，IPVS 并不需要在宿主机上为每个 Pod 设置 iptables 规则，而是把对这些“规则”的处理放到了内核态，从而极大地降低了维护这些规则的代价。这也正印证了我在前面提到过的，“将重要操作放入内核态”是提高性能的重要手段。</strong></p><p><strong>所以，在大规模集群里，我非常建议你为 kube-proxy 设置–proxy-mode=ipvs 来开启这个功能。它为 Kubernetes 集群规模带来的提升，还是非常巨大的。</strong></p><p><strong>总结</strong>：**
**ClusterIP 模式的 Service 为你提供的，就是一个 Pod 的稳定的 IP 地址，即 VIP。并且，这里 Pod 和 Service 的关系是可以通过 Label 确定的。</p><p><strong>而 Headless Service 为你提供的，则是一个 Pod 的稳定的 DNS 名字，并且，这个名字是可以通过 Pod 名字和 Service 名字拼接出来的。</strong></p><h4 id=从外界连通service的方式><strong>从外界连通Service的方式”</strong></h4><p><strong>如何从外部（Kubernetes 集群之外），访问到 Kubernetes 里创建的 Service？</strong></p><ol><li><strong>NodePort</strong></li><li><strong>LoadBalancer</strong></li><li><strong>ExternalName</strong></li><li><strong>ingrss</strong></li></ol><p><strong>NodePort注意点：一台宿主机上的 iptables 规则，会设置为只将 IP 包转发给运行在这台宿主机上的 Pod。当然，这也就意味着如果在一台宿主机上，没有任何一个被代理的 Pod 存在，比如上图中的 node 2，那么你使用 node 2 的 IP 地址访问这个 Service，就是无效的。此时，你的请求会直接被 DROP 掉。</strong></p><p><strong>LoadBalancer：适用于公有云上的 Kubernetes 服务，使用了一个叫作 CloudProvider 的转接层，来跟公有云本身的 API 进行对接。所以，在上述 LoadBalancer 类型的 Service 被提交后，Kubernetes 就会调用 CloudProvider 在公有云上为你创建一个负载均衡服务，并且把被代理的 Pod 的 IP 地址配置给负载均衡服务做后端。</strong></p><p><strong>Ingress：全局的、为了代理不同后端 Service 而设置的负载均衡服务；其实就是 Kubernetes 项目对“反向代理”的一种抽象。可以根据 Ingress 对象和被代理后端 Service 的变化，来自动进行更新的负载均衡器。</strong></p><p><strong>目前，Ingress 只能工作在七层，而 Service 只能工作在四层。所以当你想要在 Kubernetes 里为应用进行 TLS 配置等 HTTP 相关的操作时，都必须通过 Ingress 来进行。</strong></p><h3 id=k8s资源模型与资源管理>k8s资源模型与资源管理</h3><p><strong>在 Kubernetes 中，像 CPU 这样的资源被称作“可压缩资源”（compressible resources）。它的典型特点是，当可压缩资源不足时，Pod 只会“饥饿”，但不会退出。</strong></p><p><strong>而像内存这样的资源，则被称作“不可压缩资源（incompressible resources）。当不可压缩资源不足时，Pod 就会因为 OOM（Out-Of-Memory）被内核杀掉。</strong></p><p><strong>而由于 Pod 可以由多个 Container 组成，所以 CPU 和内存资源的限额，是要配置在每个 Container 的定义上的。这样，Pod 整体的资源配置，就由这些 Container 的配置值累加得到。</strong></p><p><strong>其中，Kubernetes 里为 CPU 设置的单位是“CPU 的个数”。比如，cpu=1 指的就是，这个 Pod 的 CPU 限额是 1 个 CPU。当然，具体“1 个 CPU”在宿主机上如何解释，是 1 个 CPU 核心，还是 1 个 vCPU，还是 1 个 CPU 的超线程（Hyperthread），完全取决于宿主机的 CPU 实现方式。Kubernetes 只负责保证 Pod 能够使用到“1 个 CPU”的计算能力。</strong></p><p><strong>此外，Kubernetes 允许你将 CPU 限额设置为分数，比如在我们的例子里，CPU limits 的值就是 500m。所谓 500m，指的就是 500 millicpu，也就是 0.5 个 CPU 的意思。这样，这个 Pod 就会被分配到 1 个 CPU 一半的计算能力。</strong></p><p><strong>你也可以直接把这个配置写成 cpu=0.5。但在实际使用时，我还是推荐你使用 500m 的写法，毕竟这才是 Kubernetes 内部通用的 CPU 表示方式。</strong></p><p><strong>而对于内存资源来说，它的单位自然就是 bytes。Kubernetes 支持你使用 Ei、Pi、Ti、Gi、Mi、Ki（或者 E、P、T、G、M、K）的方式来作为 bytes 的值。比如，在我们的例子里，Memory requests 的值就是 64MiB (2 的 26 次方 bytes) 。这里要注意区分 MiB（mebibyte）和 MB（megabyte）的区别。</strong></p><blockquote><p><strong>备注：1Mi=1024</strong><em>1024；1M=1000</em>1000</p></blockquote><p><strong>，Kubernetes 里 Pod 的 CPU 和内存资源，实际上还要分为 limits 和 requests 两种情况</strong></p><h4 id=k8s默认资源调度器>k8s默认资源调度器</h4><h4 id=k8s容器运行时>k8s容器运行时</h4><ol><li><strong>sig-Node</strong></li><li><strong>CRI</strong></li></ol><h4 id=k8s容器监控和日志>k8s容器监控和日志</h4><h5 id=监控数据分类>监控数据分类</h5><p><strong>按照 Metrics 数据的来源，来对 Kubernetes 的监控体系分类</strong></p><ol><li><strong>宿主机的监控数据</strong></li><li><strong>Kubernetes 的 API Server、kubelet 等组件的 /metrics API</strong></li><li><strong>Kubernetes 相关的监控数据，包括 Pod、Node、容器、Service 等主要 Kubernetes 核心概念的 Metrics</strong></li></ol><p><strong>其中，容器相关的 Metrics 主要来自于 kubelet 内置的 cAdvisor 服务。在 kubelet 启动后，cAdvisor 服务也随之启动，而它能够提供的信息，可以细化到每一个容器的 CPU 、文件系统、内存、网络等资源的使用情况。</strong></p><h5 id=custom-metrics>Custom Metrics</h5><h5 id=容器日志收集与管理>容器日志收集与管理</h5><p><strong>方案：</strong></p><ol><li><strong>Node上部署logging agent，将日志文件转发到后端存储里保存。</strong></li></ol><p><strong>不难看到，这里的核心就在于 logging agent ，它一般都会以 DaemonSet 的方式运行在节点上，然后将宿主机上的容器日志目录挂载进去，最后由 logging-agent 把日志转发出去。</strong></p><hr><p><strong>举个例子，我们可以通过 Fluentd 项目作为宿主机上的 logging-agent，然后把日志转发到远端的 ElasticSearch 里保存起来供将来进行检索。具体的操作过程，你可以通过</strong><a href=https://kubernetes.io/docs/user-guide/logging/elasticsearch>阅读这篇文档</a>来了解。另外，在很多 Kubernetes 的部署里，会自动为你启用 <a href=https://linux.die.net/man/8/logrotate>logrotate</a>，在日志文件超过 10MB 的时候自动对日志文件进行 rotate 操作。</p><p><strong>可以看到，在 Node 上部署 logging agent 最大的优点，在于一个节点只需要部署一个 agent，并且不会对应用和 Pod 有任何侵入性。所以，这个方案，在社区里是最常用的一种。</strong></p><p><strong>但是也不难看到，这种方案的不足之处就在于，它要求应用输出的日志，都必须是直接输出到容器的 stdout 和 stderr 里。</strong></p><ol start=2><li><strong>针对1的不足，当容器的日志只能输出到某些文件里的时候，我们可以通过一个 sidecar 容器把这些日志文件重新输出到 sidecar 的 stdout 和 stderr 上，这样就能够继续使用第一种方案了</strong></li><li><strong>就是通过一个 sidecar 容器，直接把应用的日志文件发送到远程存储里面去。也就是相当于把方案一里的 logging agent，放在了应用 Pod 里。</strong></li></ol><p><strong>在这种方案里，你的应用还可以直接把日志输出到固定的文件里而不是 stdout，你的 logging-agent 还可以使用 fluentd，后端存储还可以是 ElasticSearch。只不过， fluentd 的输入源，变成了应用的日志文件。一般来说，我们会把 fluentd 的输入源配置保存在一个 ConfigMap 里</strong></p><p><strong>总结：</strong>
<strong>建议将应用日志输出到 stdout 和 stderr，然后通过在宿主机上部署 logging-agent 的方式来集中处理日志。</strong></p><p><strong>这种方案不仅管理简单，kubectl logs 也可以用，而且可靠性高，并且宿主机本身，很可能就自带了 rsyslogd 等非常成熟的日志收集组件来供你使用。</strong></p><p><strong>除此之外，还有一种方式就是在编写应用的时候，就直接指定好日志的存储后端</strong></p></div><footer class=post-footer><div class=post-tags><a href=/tags/%e6%8a%80%e6%9c%af rel=tag title=技术>#技术#</a>
<a href=/tags/%e5%ae%b9%e5%99%a8 rel=tag title=容器>#容器#</a>
<a href=/tags/docker rel=tag title=docker>#docker#</a>
<a href=/tags/k8s rel=tag title=k8s>#k8s#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-img><img src=/img/qq_qrcode.png width=129px height=129px><div style=text-align:center>QQ扫一扫交流</div></div><div class=article-copyright-info><p><span>声明：</span>K8s</p><p><span>链接：</span>/post/k8s/</p><p><span>作者：</span>菩提本树</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick="var qr=document.getElementById('QR');qr.style.display==='none'?qr.style.display='block':qr.style.display='none'">
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"></div><div class="post-nav-prev post-nav-item"><a href=/post/docker_learn_note/ rel=prev title=容器学习笔记>容器学习笔记
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/avatar.png alt=菩提本树><p class=site-author-name itemprop=name>菩提本树</p><p class="site-description motion-element" itemprop=description>工作是一种乐趣时，生活是一种享受!</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>2</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>1</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>4</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/jansonlv/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span>
<span class=links-of-author-item><a href=https://www.zhihu.com target=_blank title=知乎><i class="fa fa-fw fa-globe"></i>
知乎</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class=links-of-blogroll-title><i class="fa fa-fw fa-globe"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gohugo.io/ title=hugo target=_blank>hugo</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn/ title=凡梦星尘 target=_blank>凡梦星尘</a></li><li class=links-of-blogroll-item><a href=https://tech.qimao.com/ title=qimao target=_blank>qimao</a></li><li class=links-of-blogroll-item><a href=https://www.liaoxuefeng.com/ title=廖雪峰 target=_blank>廖雪峰</a></li></ul></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/docker>Docker</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E5%AE%B9%E5%99%A8>容器</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%8A%80%E6%9C%AF>技术</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/k8s>K8s</a></li></ul></div><div class="links-of-blogroll motion-element inline"><script type=text/javascript src="//rf.revolvermaps.com/0/0/6.js?i=Your%20RevolverMapId&m=7&c=e63100&cr1=ffffff&f=arial&l=0&bv=90&lx=-420&ly=420&hi=20&he=7&hc=a8ddff&rs=80" async></script></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2021</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>现实和梦想</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.83.1</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><span class=cnzz_icon id="cnzz_stat_icon_Your CNNZSiteId"><a href="//www.cnzz.com/stat/website.php?web_id=Your%20CNNZSiteId" target=_blank title=站长统计><img border=0 hspace=0 vspace=0 src=//icon.cnzz.com/img/pic1.gif></a></span>
<script type=text/javascript>(function(){var a=document.createElement('script'),b;a.type='text/javascript',a.async=!0,a.charset='utf-8',a.src='https://s4.cnzz.com/z_stat.php?id=Your CNNZSiteId&show=pic1',b=document.getElementsByTagName('script')[0],b.parentNode.insertBefore(a,b)})()</script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span class=site-uv><i class="fa fa-user"></i>
<span class=busuanzi-value id=busuanzi_value_site_uv></span></span><span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i>
<span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=github.com style=font-weight:700 target=_blank>github.com</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href=github.io target=_blank>github.io</a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/2.1.4/jquery.min.js></script><script type=text/javascript src=/js/search.js></script><script type=text/javascript src=/js/affix.js></script><script type=text/javascript src=/js/scrollspy.js></script><script type=text/javascript>function getCntViewHeight(){var b=$('#content').height(),a=$(window).height(),c=b>a?b-a:$(document).height()-a;return c}function getScrollbarWidth(){var a=$('<div />').addClass('scrollbar-measure').prependTo('body'),b=a[0],c=b.offsetWidth-b.clientWidth;return a.remove(),c}function registerBackTop(){var b=50,a=$('.back-to-top');$(window).on('scroll',function(){var d,e,f,c,g;a.toggleClass('back-to-top-on',window.pageYOffset>b),d=$(window).scrollTop(),e=getCntViewHeight(),f=d/e,c=Math.round(f*100),g=c>100?100:c,$('#scrollpercent>span').html(g)}),a.on('click',function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){var a='.post-toc',d=$(a),b='.active-current';d.on('activate.bs.scrollspy',function(){var b=$(a+' .active').last();c(),b.addClass('active-current')}).on('clear.bs.scrollspy',c),$('body').scrollspy({target:a});function c(){$(a+' '+b).removeClass(b.substring(1))}}function initAffix(){var a=$('.header-inner').height(),b=parseInt($('.main').css('padding-bottom'),10),c=a+10;$('.sidebar-inner').affix({offset:{top:c,bottom:b}}),$(document).on('affixed.bs.affix',function(){updateTOCHeight(document.body.clientHeight-100)})}function initTOCDimension(){var a,b;$(window).on('resize',function(){a&&clearTimeout(a),a=setTimeout(function(){var a=document.body.clientHeight-100;updateTOCHeight(a)},0)}),updateTOCHeight(document.body.clientHeight-100),b=getScrollbarWidth(),$('.post-toc').css('width','calc(100% + '+b+'px)')}function updateTOCHeight(a){a=a||'auto',$('.post-toc').css('max-height',a)}$(function(){var b=$('.header-inner').height()+10,c,d,a,e;$('#sidebar').css({'margin-top':b}).show(),c=$('.header-inner').height(),d=$('.sidebar-inner').height(),a=c+d+50,e=$('.content-wrap').height(),e<a&&$('.content-wrap').css('height',a+50),$('.site-nav-toggle').on('click',function(){var a=$('.site-nav'),e=$('.toggle'),b='site-nav-on',f='toggle-close',c=a.hasClass(b),g=c?'slideUp':'slideDown',d=c?'removeClass':'addClass';a.stop()[g]('normal',function(){a[d](b),e[d](f)})}),registerBackTop(),initScrollSpy(),initAffix(),initTOCDimension(),$('.sidebar-nav-toc').click(function(){$(this).addClass('sidebar-nav-active'),$(this).next().removeClass('sidebar-nav-active'),$('.'+$(this).next().attr('data-target')).toggle(500),$('.'+$(this).attr('data-target')).toggle(500)}),$('.sidebar-nav-overview').click(function(){$(this).addClass('sidebar-nav-active'),$(this).prev().removeClass('sidebar-nav-active'),$('.'+$(this).prev().attr('data-target')).toggle(500),$('.'+$(this).attr('data-target')).toggle(500)})})</script><script src=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.js></script><script type=text/javascript>$(function(){$('.post-body').viewer()})</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script><script>(function(){var a=document.createElement('script'),c=window.location.protocol.split(':')[0],b;c==='https'?a.src='https://zz.bdstatic.com/linksubmit/push.js':a.src='http://push.zhanzhang.baidu.com/push.js',b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script><script type=text/javascript>$(function(){var b,a;document.body.clientWidth>900&&(b=document.getElementsByTagName('HEAD').item(0),a=document.createElement("script"),a.type="text/javascript",a.innerHTML='(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",(\'https:\' == document.location.protocol ? \'https:\' : \'http:\') + "//widget.daovoice.io/widget/Your DaoVoiceId.js","daovoice")',b.appendChild(a),daovoice('init',{app_id:"Your DaoVoiceId"}),daovoice('update'))})</script></body></html>